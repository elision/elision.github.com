<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>ElisionParser - Elision API Version 0.5.0 Build 201305070000 - ornl.elision.parse.ElisionParser</title>
          <meta name="description" content="ElisionParser - Elision API Version 0.5.0 Build 201305070000 - ornl.elision.parse.ElisionParser" />
          <meta name="keywords" content="ElisionParser Elision API Version 0.5.0 Build 201305070000 ornl.elision.parse.ElisionParser" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'ornl.elision.parse.ElisionParser';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../lib/class_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="ornl">ornl</a>.<a href="../package.html" class="extype" name="ornl.elision">elision</a>.<a href="package.html" class="extype" name="ornl.elision.parse">parse</a></p>
        <h1>ElisionParser</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">ElisionParser</span><span class="result"> extends <span class="extype" name="org.parboiled.scala.Parser">Parser</span> with <a href="AbstractParser.html" class="extype" name="ornl.elision.parse.AbstractParser">AbstractParser</a></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Implement a parser for Elision atoms.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="AbstractParser.html" class="extype" name="ornl.elision.parse.AbstractParser">AbstractParser</a>, <span class="extype" name="org.parboiled.scala.Parser">Parser</span>, <a href="../../../scala/package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="ornl.elision.parse.ElisionParser"><span>ElisionParser</span></li><li class="in" name="ornl.elision.parse.AbstractParser"><span>AbstractParser</span></li><li class="in" name="org.parboiled.scala.Parser"><span>Parser</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="ornl.elision.parse.ElisionParser#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;init&gt;(name:String,trace:Boolean):ornl.elision.parse.ElisionParser"></a>
      <a id="&lt;init&gt;:ElisionParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">ElisionParser</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="trace">trace: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>Name of the input source (typically a filename).  This should
               be <code>&quot;(console)&quot;</code> for the console, and <code>&quot;&quot;</code> for internal use.</p></dd><dt class="param">trace</dt><dd class="cmt"><p>If true, enable tracing.  False by default.
</p></dd></dl></div>
    </li></ol>
            </div>

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <a href="../../../scala/package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <a href="../../../scala/package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#AnyInteger" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AnyInteger:org.parboiled.scala.rules.Rule1[(Int,String)]"></a>
      <a id="AnyInteger:Rule1[(Int,String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">AnyInteger</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse an integer in hexadecimal, decimal, octal, or binary.</p><div class="fullcomment"><div class="comment cmt"><p>Parse an integer in hexadecimal, decimal, octal, or binary.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>An unsigned integer.
</p></dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#AnyNumber" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AnyNumber:org.parboiled.scala.rules.Rule4[Option[Boolean],(Int,String),Option[(Int,String)],Option[(Boolean,Int,String)]]"></a>
      <a id="AnyNumber:Rule4[Option[Boolean],(Int,String),Option[(Int,String)],Option[(Boolean,Int,String)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">AnyNumber</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule4">Rule4</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Boolean">Boolean</span>], (<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>), <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)], <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Boolean">Boolean</span>, <span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a number.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a number.  The number can be an integer or a float, and can be
positive or negative.
</p></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#Atom" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Atom:org.parboiled.scala.Rule1[ornl.elision.parse.AST.BA]"></a>
      <a id="Atom:Rule1[BA]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">Atom</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="AST$.html#BA=ornl.elision.parse.AST[ornl.elision.core.BasicAtom]" class="extmbr" name="ornl.elision.parse.AST.BA">BA</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse an atom.</p><div class="fullcomment"><div class="comment cmt"><p>Parse an atom.</p><p>This method handles map pairs and the applicative dot.  The map pair
is checked first, followed by the applicative dot, giving the dot the
lowest priority.  While the map pair cannot be repeated, the applicative
dot can be, and it is treated as right associative.</p><pre>Atom ::= FirstAtom (<span class="lit">"->"</span> Atom | (<span class="lit">"."</span> FirstAtom)*)</pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#Atoms" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Atoms:org.parboiled.scala.rules.Rule1[List[ornl.elision.parse.AST.BA]]"></a>
      <a id="Atoms:Rule1[List[BA]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">Atoms</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<a href="AST$.html#BA=ornl.elision.parse.AST[ornl.elision.core.BasicAtom]" class="extmbr" name="ornl.elision.parse.AST.BA">BA</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a sequence of atoms.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a sequence of atoms.  The sequence may consist of zero or more
atoms.  The end of input is matched here.</p><pre>Atoms ::= Atom* EOI</pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#BDigit" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="BDigit:org.parboiled.scala.rules.Rule0"></a>
      <a id="BDigit:Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">BDigit</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule0">Rule0</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a binary digit.</p>
    </li><li name="ornl.elision.parse.ElisionParser#BInteger" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="BInteger:org.parboiled.scala.rules.Rule1[(Int,String)]"></a>
      <a id="BInteger:Rule1[(Int,String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">BInteger</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a binary integer.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a binary integer.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>An unsigned integer.
</p></dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#BNumber" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="BNumber:org.parboiled.scala.rules.Rule3[(Int,String),Option[(Int,String)],Option[(Boolean,Int,String)]]"></a>
      <a id="BNumber:Rule3[(Int,String),Option[(Int,String)],Option[(Boolean,Int,String)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">BNumber</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule3">Rule3</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>), <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)], <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Boolean">Boolean</span>, <span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a binary number that may be either an integer or a float.</p>
    </li><li name="ornl.elision.parse.ElisionParser#BitString" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="BitString:org.parboiled.scala.rules.Rule3[Option[Boolean],(Int,String),(Int,String)]"></a>
      <a id="BitString:Rule3[Option[Boolean],(Int,String),(Int,String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">BitString</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule3">Rule3</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Boolean">Boolean</span>], (<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>), (<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]</span>
      </span>
      </h4>
      
    </li><li name="ornl.elision.parse.ElisionParser#Character" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Character:org.parboiled.scala.rules.Rule1[String]"></a>
      <a id="Character:Rule1[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">Character</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a character in a string.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a character in a string.  This may be an escape.</p><pre>Character ::= EscapedCharacter | NormalCharacter</pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#DDigit" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="DDigit:org.parboiled.scala.rules.Rule0"></a>
      <a id="DDigit:Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">DDigit</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule0">Rule0</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a decimal digit.</p>
    </li><li name="ornl.elision.parse.ElisionParser#DInteger" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DInteger:org.parboiled.scala.rules.Rule1[(Int,String)]"></a>
      <a id="DInteger:Rule1[(Int,String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">DInteger</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a decimal integer.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a decimal integer.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>An unsigned integer.
</p></dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#DNumber" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="DNumber:org.parboiled.scala.rules.Rule3[(Int,String),Option[(Int,String)],Option[(Boolean,Int,String)]]"></a>
      <a id="DNumber:Rule3[(Int,String),Option[(Int,String)],Option[(Boolean,Int,String)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">DNumber</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule3">Rule3</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>), <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)], <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Boolean">Boolean</span>, <span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a decimal number that may be either an integer or a float.</p>
    </li><li name="ornl.elision.parse.ElisionParser#EString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EString:org.parboiled.scala.rules.Rule1[String]"></a>
      <a id="EString:Rule1[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">EString</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a double-quoted string.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a double-quoted string.</p><pre>EString ::= <span class="lit">"\""</span> Character* <span class="lit">"\""</span></pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#ESymbol" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ESymbol:org.parboiled.scala.rules.Rule1[String]"></a>
      <a id="ESymbol:Rule1[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ESymbol</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a symbol.</p>
    </li><li name="ornl.elision.parse.ElisionParser#EVerb" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EVerb:org.parboiled.scala.rules.Rule1[String]"></a>
      <a id="EVerb:Rule1[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">EVerb</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a verbatim block.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a verbatim block.</p><pre>EVerb ::= [ any text in triple double-quotation-marks ]</pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#EscapedCharacter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EscapedCharacter:org.parboiled.scala.rules.Rule0"></a>
      <a id="EscapedCharacter:Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">EscapedCharacter</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule0">Rule0</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse an escaped character.</p><div class="fullcomment"><div class="comment cmt"><p>Parse an escaped character.</p><pre>EscapedCharacter ::= <span class="lit">"\" ("</span>'<span class="lit">" | "</span>\<span class="lit">""</span> | <span class="lit">"n"</span> | <span class="lit">"r"</span> | <span class="lit">"t"</span> | <span class="lit">"\")</span></pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#Exponent" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Exponent:org.parboiled.scala.rules.Rule1[(Boolean,Int,String)]"></a>
      <a id="Exponent:Rule1[(Boolean,Int,String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">Exponent</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[(<span class="extype" name="scala.Boolean">Boolean</span>, <span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse an exponent expression.</p><div class="fullcomment"><div class="comment cmt"><p>Parse an exponent expression.  The expression does not include the
linking &quot;e&quot; or &quot;p&quot; exponent indicator.
</p></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#FirstAtom" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FirstAtom:org.parboiled.scala.Rule1[ornl.elision.parse.AST.BA]"></a>
      <a id="FirstAtom:Rule1[BA]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">FirstAtom</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="AST$.html#BA=ornl.elision.parse.AST[ornl.elision.core.BasicAtom]" class="extmbr" name="ornl.elision.parse.AST.BA">BA</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse an atom with the exception of a map pair or general application.</p><div class="fullcomment"><div class="comment cmt"><p>Parse an atom with the exception of a map pair or general application.
Most atoms are matched at this point.</p><pre>FirstAtom ::= <span class="lit">"("</span> Atom <span class="lit">")"</span>
| <span class="lit">"^TYPE"</span>
| ParsedVariable
| <span class="lit">"\" ParsedVariable "</span>.<span class="lit">" FirstAtom
| "</span>{:<span class="lit">" Atom Atom "</span>:}<span class="lit">"
| "</span>{<span class="lit">" ESymbol Atom* ("</span>#<span class="lit">" ESymbol ("</span>=<span class="lit">" Atom | ParsedAtomSeq))* "</span>}<span class="lit">"
| "</span>%<span class="lit">" ParsedAlgProp ("</span>(<span class="lit">" ParsedRawAtomSeq "</span>)<span class="lit">")?
| ESymbol ( "</span>(<span class="lit">" ParsedRawAtomSeq "</span>)<span class="lit">"
          | "</span>:<span class="lit">" ("</span>OPREF<span class="lit">" | "</span>RSREF<span class="lit">" | FirstAtom)
          )?</span></pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#HDigit" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="HDigit:org.parboiled.scala.rules.Rule0"></a>
      <a id="HDigit:Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">HDigit</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule0">Rule0</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a hexadecimal digit.</p>
    </li><li name="ornl.elision.parse.ElisionParser#HInteger" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="HInteger:org.parboiled.scala.rules.Rule1[(Int,String)]"></a>
      <a id="HInteger:Rule1[(Int,String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">HInteger</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a hexadecimal integer.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a hexadecimal integer.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>An unsigned integer.
</p></dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#HNumber" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="HNumber:org.parboiled.scala.rules.Rule3[(Int,String),Option[(Int,String)],Option[(Boolean,Int,String)]]"></a>
      <a id="HNumber:Rule3[(Int,String),Option[(Int,String)],Option[(Boolean,Int,String)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">HNumber</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule3">Rule3</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>), <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)], <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Boolean">Boolean</span>, <span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a hexadecimal number that may be either an integer or a float.</p>
    </li><li name="ornl.elision.parse.ElisionParser#NormalCharacter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="NormalCharacter:org.parboiled.scala.rules.Rule0"></a>
      <a id="NormalCharacter:Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">NormalCharacter</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule0">Rule0</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a normal character.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a normal character.</p><pre>NormalCharacter ::= [not \ or <span class="lit">"]</span></pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#ODigit" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ODigit:org.parboiled.scala.rules.Rule0"></a>
      <a id="ODigit:Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ODigit</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule0">Rule0</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse an octal digit.</p>
    </li><li name="ornl.elision.parse.ElisionParser#OInteger" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OInteger:org.parboiled.scala.rules.Rule1[(Int,String)]"></a>
      <a id="OInteger:Rule1[(Int,String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">OInteger</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse an octal integer.</p><div class="fullcomment"><div class="comment cmt"><p>Parse an octal integer.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>An unsigned integer.
</p></dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#ONumber" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ONumber:org.parboiled.scala.rules.Rule3[(Int,String),Option[(Int,String)],Option[(Boolean,Int,String)]]"></a>
      <a id="ONumber:Rule3[(Int,String),Option[(Int,String)],Option[(Boolean,Int,String)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ONumber</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule3">Rule3</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>), <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)], <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Boolean">Boolean</span>, <span class="extype" name="scala.Int">Int</span>, <span class="extype" name="java.lang.String">String</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse an octal number that may be either an integer or a float.</p>
    </li><li name="ornl.elision.parse.ElisionParser#OperatorPropertiesNode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OperatorPropertiesNode:org.parboiled.scala.rules.Rule1[List[ornl.elision.parse.AST[ornl.elision.core.AlgProp]{definterpret(context:ornl.elision.context.Context):ornl.elision.core.AlgPropwithProductwithSerializable}]]"></a>
      <a id="OperatorPropertiesNode:Rule1[List[AST[AlgProp]{definterpret(context:ornl.elision.context.Context):ornl.elision.core.AlgPropwithProductwithSerializable}]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">OperatorPropertiesNode</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<a href="AST.html" class="extype" name="ornl.elision.parse.AST">AST</a>[<a href="../core/AlgProp.html" class="extype" name="ornl.elision.core.AlgProp">AlgProp</a>] { def interpret(context: ornl.elision.context.Context): ornl.elision.core.AlgProp with Product with Serializable }]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a long-form algebraic properties specification.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a long-form algebraic properties specification.</p><pre>OperatorPropertiesNode ::=
( <span class="lit">"not"</span>? ( <span class="lit">"associative"</span> | <span class="lit">"commutative"</span> | <span class="lit">"idempotent"</span> )
| <span class="lit">"absorber"</span> Atom
| <span class="lit">"identity"</span> Atom ) (<span class="lit">","</span> OperatorPropertiesNode)*</pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#OperatorPrototype" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OperatorPrototype:org.parboiled.scala.rules.Rule1[(ornl.elision.parse.AST.BAwithornl.elision.parse.AST.Naked,List[ornl.elision.parse.AST.BA],ornl.elision.parse.AST.BA)]"></a>
      <a id="OperatorPrototype:Rule1[(BAwithNaked,List[BA],BA)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">OperatorPrototype</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[(<a href="AST$.html#BA=ornl.elision.parse.AST[ornl.elision.core.BasicAtom]" class="extmbr" name="ornl.elision.parse.AST.BA">BA</a> with <a href="AST$$Naked.html" class="extype" name="ornl.elision.parse.AST.Naked">Naked</a>, <a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<a href="AST$.html#BA=ornl.elision.parse.AST[ornl.elision.core.BasicAtom]" class="extmbr" name="ornl.elision.parse.AST.BA">BA</a>], <a href="AST$.html#BA=ornl.elision.parse.AST[ornl.elision.core.BasicAtom]" class="extmbr" name="ornl.elision.parse.AST.BA">BA</a>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse an operator prototype.</p><div class="fullcomment"><div class="comment cmt"><p>Parse an operator prototype.</p><pre>OperatorPrototype ::= ESymbol <span class="lit">"("</span> ParsedRawAtomSeq <span class="lit">")"</span> (<span class="lit">":"</span> FirstAtom)?</pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#ParsedAlgProp" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ParsedAlgProp:org.parboiled.scala.rules.Rule1[List[ornl.elision.parse.AST[ornl.elision.core.AlgProp]{definterpret(context:ornl.elision.context.Context):ornl.elision.core.AlgPropwithProductwithSerializable}]]"></a>
      <a id="ParsedAlgProp:Rule1[List[AST[AlgProp]{definterpret(context:ornl.elision.context.Context):ornl.elision.core.AlgPropwithProductwithSerializable}]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ParsedAlgProp</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<a href="AST.html" class="extype" name="ornl.elision.parse.AST">AST</a>[<a href="../core/AlgProp.html" class="extype" name="ornl.elision.core.AlgProp">AlgProp</a>] { def interpret(context: ornl.elision.context.Context): ornl.elision.core.AlgProp with Product with Serializable }]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse an algebraic properties specification.</p><div class="fullcomment"><div class="comment cmt"><p>Parse an algebraic properties specification.</p><pre>ParsedAlgProp ::= OperatorPropertiesNode
| ( <span class="lit">"B["</span> Atom <span class="lit">"]"</span>
  | <span class="lit">"D["</span> Atom <span class="lit">"]"</span>
  | <span class="lit">"A"</span> (<span class="lit">"["</span> Atom <span class="lit">"]"</span>)?
  | <span class="lit">"C"</span> (<span class="lit">"["</span> Atom <span class="lit">"]"</span>)?
  | <span class="lit">"D"</span> (<span class="lit">"["</span> Atom <span class="lit">"]"</span>)?
  | <span class="lit">"!A"</span>
  | <span class="lit">"!C"</span>
  | <span class="lit">"!I"</span> )*</pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#ParsedRawAtomSeq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ParsedRawAtomSeq:org.parboiled.scala.rules.Rule1[List[ornl.elision.parse.AST.BA]]"></a>
      <a id="ParsedRawAtomSeq:Rule1[List[BA]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ParsedRawAtomSeq</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<a href="AST$.html#BA=ornl.elision.parse.AST[ornl.elision.core.BasicAtom]" class="extmbr" name="ornl.elision.parse.AST.BA">BA</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a list of atoms, separated by commas.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a list of atoms, separated by commas.  No concept of associativity,
commutativity, etc., is inferred at this point.</p><pre>ParsedRawAtomSeq ::= Atom (<span class="lit">","</span> ParsedRawAtomSeq)*</pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#ParsedVariable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ParsedVariable:org.parboiled.scala.rules.Rule1[ornl.elision.parse.AST[ornl.elision.core.Variable]]"></a>
      <a id="ParsedVariable:Rule1[AST[Variable]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ParsedVariable</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[<a href="AST.html" class="extype" name="ornl.elision.parse.AST">AST</a>[<a href="../core/Variable.html" class="extype" name="ornl.elision.core.Variable">Variable</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a variable or metavariable.</p><div class="fullcomment"><div class="comment cmt"><p>Parse a variable or metavariable.</p><pre>ParsedVariable ::= ( <span class="lit">"`$``$`"</span> | <span class="lit">"`$`"</span> ) ESymbol
(<span class="lit">"{"</span> Atom <span class="lit">"}"</span>)? (<span class="lit">":"</span> FirstAtom)? (<span class="lit">"@"</span> ESymbol)*</pre></div></div>
    </li><li name="ornl.elision.parse.ElisionParser#SymChar" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SymChar:org.parboiled.scala.rules.Rule1[String]"></a>
      <a id="SymChar:Rule1[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">SymChar</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule1">Rule1</span>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a character that is part of a symbol.</p>
    </li><li name="ornl.elision.parse.ElisionParser#SymNorm" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SymNorm:org.parboiled.scala.rules.Rule0"></a>
      <a id="SymNorm:Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">SymNorm</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule0">Rule0</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse a &quot;normal&quot; non-escaped character that is part of a symbol.</p>
    </li><li name="ornl.elision.parse.ElisionParser#WS" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="WS:org.parboiled.scala.Rule0"></a>
      <a id="WS:Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">WS</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse ignorable whitespace.</p>
    </li><li name="org.parboiled.scala.Parser#anyOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyOf(chars:org.parboiled.support.Characters):org.parboiled.scala.Rule0"></a>
      <a id="anyOf(Characters):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="org.parboiled.support.Characters">Characters</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#anyOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyOf(chars:Array[Char]):org.parboiled.scala.Rule0"></a>
      <a id="anyOf(Array[Char]):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#anyOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyOf(s:String):org.parboiled.scala.Rule0"></a>
      <a id="anyOf(String):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="s">s: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#append" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="append(front:StringBuilder,last:String):StringBuilder"></a>
      <a id="append(StringBuilder,String):StringBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">append</span><span class="params">(<span name="front">front: <a href="../../../scala/package.html#StringBuilder=StringBuilder" class="extmbr" name="scala.StringBuilder">StringBuilder</a></span>, <span name="last">last: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.mutable.StringBuilder">StringBuilder</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Accumulate a character into a string.</p><div class="fullcomment"><div class="comment cmt"><p>Accumulate a character into a string.  The character may actually be an
escape sequence that will be interpreted here.</p><p>See <code>toEString</code> for the reverse conversion.</p><p>The following escapes are interpreted.</p><pre>\<span class="lit">"  -> double quotation mark
\`  -> backtick
\\  -> backslash
\n  -> newline
\t  -> tab
\r  -> carriage return</span></pre></div><dl class="paramcmts block"><dt class="param">front</dt><dd class="cmt"><p>The string to get the new character appended at the end.</p></dd><dt class="param">last</dt><dd class="cmt"><p>The new character, possibly an escape to interpret.</p></dd><dt>returns</dt><dd class="cmt"><p>The new string.
</p></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#buildParseTree" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buildParseTree:Boolean"></a>
      <a id="buildParseTree:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buildParseTree</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#ch" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ch(c:&lt;?&gt;):org.parboiled.scala.CharRule"></a>
      <a id="ch(Char):CharRule"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ch</span><span class="params">(<span name="c">c: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.CharRule">CharRule</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <a href="../../../scala/package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#construct" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="construct(chars:List[String]):String"></a>
      <a id="construct(List[String]):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">construct</span><span class="params">(<span name="chars">chars: <a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Given a list of strings, each of which represents a single character
(possibly as an escape), concatenate them into a single string.</p><div class="fullcomment"><div class="comment cmt"><p>Given a list of strings, each of which represents a single character
(possibly as an escape), concatenate them into a single string.
</p></div><dl class="paramcmts block"><dt class="param">chars</dt><dd class="cmt"><p>The list of characters.</p></dd><dt>returns</dt><dd class="cmt"><p>The composed string.
</p></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="../../../scala/package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#ignoreCase" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ignoreCase(chars:Array[Char]):org.parboiled.scala.Rule0"></a>
      <a id="ignoreCase(Array[Char]):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ignoreCase</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#ignoreCase" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ignoreCase(s:String):org.parboiled.scala.Rule0"></a>
      <a id="ignoreCase(String):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ignoreCase</span><span class="params">(<span name="s">s: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#ignoreCase" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ignoreCase(c:Char):org.parboiled.scala.Rule0"></a>
      <a id="ignoreCase(Char):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ignoreCase</span><span class="params">(<span name="c">c: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#nTimes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nTimes[A&lt;:&lt;?&gt;,B&lt;:&lt;?&gt;](times:&lt;?&gt;,sub:&lt;?&gt;,separator:&lt;?&gt;):org.parboiled.scala.Rule1[List[(A,B)]]"></a>
      <a id="nTimes[A,B](Int,Rule2[A,B],Rule0):Rule1[List[(A,B)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nTimes</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="times">times: <span class="extype" name="scala.Int">Int</span></span>, <span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule2">Rule2</span>[<span class="extype" name="org.parboiled.scala.Parser.nTimes.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.nTimes.B">B</span>]</span>, <span name="separator">separator: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[(<span class="extype" name="org.parboiled.scala.Parser.nTimes.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.nTimes.B">B</span>)]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#nTimes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nTimes[A&lt;:&lt;?&gt;,B&lt;:&lt;?&gt;](times:&lt;?&gt;,sub:&lt;?&gt;):org.parboiled.scala.Rule1[List[(A,B)]]"></a>
      <a id="nTimes[A,B](Int,Rule2[A,B]):Rule1[List[(A,B)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nTimes</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="times">times: <span class="extype" name="scala.Int">Int</span></span>, <span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule2">Rule2</span>[<span class="extype" name="org.parboiled.scala.Parser.nTimes.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.nTimes.B">B</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[(<span class="extype" name="org.parboiled.scala.Parser.nTimes.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.nTimes.B">B</span>)]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#nTimes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nTimes[A&lt;:&lt;?&gt;](times:&lt;?&gt;,sub:&lt;?&gt;,separator:&lt;?&gt;):org.parboiled.scala.Rule1[List[A]]"></a>
      <a id="nTimes[A](Int,Rule1[A],Rule0):Rule1[List[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nTimes</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="times">times: <span class="extype" name="scala.Int">Int</span></span>, <span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="org.parboiled.scala.Parser.nTimes.A">A</span>]</span>, <span name="separator">separator: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<span class="extype" name="org.parboiled.scala.Parser.nTimes.A">A</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#nTimes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nTimes[A&lt;:&lt;?&gt;](times:&lt;?&gt;,sub:&lt;?&gt;):org.parboiled.scala.Rule1[List[A]]"></a>
      <a id="nTimes[A](Int,Rule1[A]):Rule1[List[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nTimes</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="times">times: <span class="extype" name="scala.Int">Int</span></span>, <span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="org.parboiled.scala.Parser.nTimes.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<span class="extype" name="org.parboiled.scala.Parser.nTimes.A">A</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#nTimes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nTimes[Z&lt;:&lt;?&gt;](times:&lt;?&gt;,sub:&lt;?&gt;,separator:&lt;?&gt;):org.parboiled.scala.ReductionRule1[Z,Z]"></a>
      <a id="nTimes[Z](Int,ReductionRule1[Z,Z],Rule0):ReductionRule1[Z,Z]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nTimes</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="times">times: <span class="extype" name="scala.Int">Int</span></span>, <span name="sub">sub: <span class="extype" name="org.parboiled.scala.ReductionRule1">ReductionRule1</span>[<span class="extype" name="org.parboiled.scala.Parser.nTimes.Z">Z</span>, <span class="extype" name="org.parboiled.scala.Parser.nTimes.Z">Z</span>]</span>, <span name="separator">separator: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.ReductionRule1">ReductionRule1</span>[<span class="extype" name="org.parboiled.scala.Parser.nTimes.Z">Z</span>, <span class="extype" name="org.parboiled.scala.Parser.nTimes.Z">Z</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#nTimes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nTimes[Z&lt;:&lt;?&gt;](times:&lt;?&gt;,sub:&lt;?&gt;):org.parboiled.scala.ReductionRule1[Z,Z]"></a>
      <a id="nTimes[Z](Int,ReductionRule1[Z,Z]):ReductionRule1[Z,Z]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nTimes</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="times">times: <span class="extype" name="scala.Int">Int</span></span>, <span name="sub">sub: <span class="extype" name="org.parboiled.scala.ReductionRule1">ReductionRule1</span>[<span class="extype" name="org.parboiled.scala.Parser.nTimes.Z">Z</span>, <span class="extype" name="org.parboiled.scala.Parser.nTimes.Z">Z</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.ReductionRule1">ReductionRule1</span>[<span class="extype" name="org.parboiled.scala.Parser.nTimes.Z">Z</span>, <span class="extype" name="org.parboiled.scala.Parser.nTimes.Z">Z</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#nTimes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nTimes(times:&lt;?&gt;,sub:&lt;?&gt;,separator:&lt;?&gt;):org.parboiled.scala.Rule0"></a>
      <a id="nTimes(Int,Rule0,Rule0):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nTimes</span><span class="params">(<span name="times">times: <span class="extype" name="scala.Int">Int</span></span>, <span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>, <span name="separator">separator: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#nTimes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nTimes(times:&lt;?&gt;,sub:&lt;?&gt;):org.parboiled.scala.Rule0"></a>
      <a id="nTimes(Int,Rule0):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nTimes</span><span class="params">(<span name="times">times: <span class="extype" name="scala.Int">Int</span></span>, <span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#name" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="name:String"></a>
      <a id="name:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">name</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Name of the input source (typically a filename).</p><div class="fullcomment"><div class="comment cmt"><p>Name of the input source (typically a filename).  This should
               be <code>&quot;(console)&quot;</code> for the console, and <code>&quot;&quot;</code> for internal use.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="ornl.elision.parse.ElisionParser">ElisionParser</a> â†’ <a href="AbstractParser.html" class="extype" name="ornl.elision.parse.AbstractParser">AbstractParser</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="../../../scala/package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#noneOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="noneOf(chars:Array[Char]):org.parboiled.scala.Rule0"></a>
      <a id="noneOf(Array[Char]):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">noneOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#noneOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="noneOf(s:String):org.parboiled.scala.Rule0"></a>
      <a id="noneOf(String):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">noneOf</span><span class="params">(<span name="s">s: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#oneOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneOrMore[A,B](sub:org.parboiled.scala.Rule2[A,B],separator:org.parboiled.scala.Rule0):org.parboiled.scala.Rule1[List[(A,B)]]"></a>
      <a id="oneOrMore[A,B](Rule2[A,B],Rule0):Rule1[List[(A,B)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOrMore</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule2">Rule2</span>[<span class="extype" name="org.parboiled.scala.Parser.oneOrMore.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.oneOrMore.B">B</span>]</span>, <span name="separator">separator: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[(<span class="extype" name="org.parboiled.scala.Parser.oneOrMore.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.oneOrMore.B">B</span>)]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#oneOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneOrMore[A](sub:org.parboiled.scala.Rule1[A],separator:org.parboiled.scala.Rule0):org.parboiled.scala.Rule1[List[A]]"></a>
      <a id="oneOrMore[A](Rule1[A],Rule0):Rule1[List[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOrMore</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="org.parboiled.scala.Parser.oneOrMore.A">A</span>]</span>, <span name="separator">separator: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<span class="extype" name="org.parboiled.scala.Parser.oneOrMore.A">A</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#oneOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneOrMore(sub:org.parboiled.scala.Rule0,separator:org.parboiled.scala.Rule0):org.parboiled.scala.Rule0"></a>
      <a id="oneOrMore(Rule0,Rule0):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOrMore</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>, <span name="separator">separator: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#oneOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneOrMore[A,B](sub:org.parboiled.scala.Rule2[A,B]):org.parboiled.scala.Rule1[List[(A,B)]]"></a>
      <a id="oneOrMore[A,B](Rule2[A,B]):Rule1[List[(A,B)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOrMore</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule2">Rule2</span>[<span class="extype" name="org.parboiled.scala.Parser.oneOrMore.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.oneOrMore.B">B</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[(<span class="extype" name="org.parboiled.scala.Parser.oneOrMore.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.oneOrMore.B">B</span>)]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#oneOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneOrMore[A](sub:org.parboiled.scala.Rule1[A]):org.parboiled.scala.Rule1[List[A]]"></a>
      <a id="oneOrMore[A](Rule1[A]):Rule1[List[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOrMore</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="org.parboiled.scala.Parser.oneOrMore.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<span class="extype" name="org.parboiled.scala.Parser.oneOrMore.A">A</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#oneOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneOrMore[Z](sub:org.parboiled.scala.ReductionRule1[Z,Z]):org.parboiled.scala.ReductionRule1[Z,Z]"></a>
      <a id="oneOrMore[Z](ReductionRule1[Z,Z]):ReductionRule1[Z,Z]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOrMore</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.ReductionRule1">ReductionRule1</span>[<span class="extype" name="org.parboiled.scala.Parser.oneOrMore.Z">Z</span>, <span class="extype" name="org.parboiled.scala.Parser.oneOrMore.Z">Z</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.ReductionRule1">ReductionRule1</span>[<span class="extype" name="org.parboiled.scala.Parser.oneOrMore.Z">Z</span>, <span class="extype" name="org.parboiled.scala.Parser.oneOrMore.Z">Z</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#oneOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneOrMore(sub:org.parboiled.scala.Rule0):org.parboiled.scala.Rule0"></a>
      <a id="oneOrMore(Rule0):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOrMore</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#optional" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optional[A,B](sub:org.parboiled.scala.Rule2[A,B]):org.parboiled.scala.Rule1[Option[(A,B)]]"></a>
      <a id="optional[A,B](Rule2[A,B]):Rule1[Option[(A,B)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optional</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule2">Rule2</span>[<span class="extype" name="org.parboiled.scala.Parser.optional.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.optional.B">B</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="org.parboiled.scala.Parser.optional.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.optional.B">B</span>)]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#optional" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optional[A](sub:org.parboiled.scala.Rule1[A]):org.parboiled.scala.Rule1[Option[A]]"></a>
      <a id="optional[A](Rule1[A]):Rule1[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optional</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="org.parboiled.scala.Parser.optional.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="org.parboiled.scala.Parser.optional.A">A</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#optional" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optional[Z](sub:org.parboiled.scala.ReductionRule1[Z,Z]):org.parboiled.scala.ReductionRule1[Z,Z]"></a>
      <a id="optional[Z](ReductionRule1[Z,Z]):ReductionRule1[Z,Z]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optional</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.ReductionRule1">ReductionRule1</span>[<span class="extype" name="org.parboiled.scala.Parser.optional.Z">Z</span>, <span class="extype" name="org.parboiled.scala.Parser.optional.Z">Z</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.ReductionRule1">ReductionRule1</span>[<span class="extype" name="org.parboiled.scala.Parser.optional.Z">Z</span>, <span class="extype" name="org.parboiled.scala.Parser.optional.Z">Z</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#optional" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optional(sub:org.parboiled.scala.Rule0):org.parboiled.scala.Rule0"></a>
      <a id="optional(Rule0):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optional</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#parseAtoms" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseAtoms(source:scala.io.Source):ornl.elision.parse.Presult"></a>
      <a id="parseAtoms(Source):Presult"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAtoms</span><span class="params">(<span name="source">source: <span class="extype" name="scala.io.Source">Source</span></span>)</span><span class="result">: <a href="Presult.html" class="extype" name="ornl.elision.parse.Presult">Presult</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Entry point to parse all atoms from the given source.</p><div class="fullcomment"><div class="comment cmt"><p>Entry point to parse all atoms from the given source.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>The input source.</p></dd><dt>returns</dt><dd class="cmt"><p>The parsing result.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="ornl.elision.parse.ElisionParser">ElisionParser</a> â†’ <a href="AbstractParser.html" class="extype" name="ornl.elision.parse.AbstractParser">AbstractParser</a></dd></dl></div>
    </li><li name="ornl.elision.parse.AbstractParser#parseAtoms" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseAtoms(line:String):ornl.elision.parse.Presult"></a>
      <a id="parseAtoms(String):Presult"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAtoms</span><span class="params">(<span name="line">line: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="Presult.html" class="extype" name="ornl.elision.parse.Presult">Presult</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Entry point to parse all atoms from the given string.</p><div class="fullcomment"><div class="comment cmt"><p>Entry point to parse all atoms from the given string.
</p></div><dl class="paramcmts block"><dt class="param">line</dt><dd class="cmt"><p>The string to parse.</p></dd><dt>returns</dt><dd class="cmt"><p>The parsing result.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="AbstractParser.html" class="extype" name="ornl.elision.parse.AbstractParser">AbstractParser</a></dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#push" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="push[A,B,C](a:=&gt;A,b:=&gt;B,c:=&gt;C):org.parboiled.scala.Rule3[A,B,C]"></a>
      <a id="push[A,B,C](â‡’A,â‡’B,â‡’C):Rule3[A,B,C]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">push</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="a">a: â‡’ <span class="extype" name="org.parboiled.scala.Parser.push.A">A</span></span>, <span name="b">b: â‡’ <span class="extype" name="org.parboiled.scala.Parser.push.B">B</span></span>, <span name="c">c: â‡’ <span class="extype" name="org.parboiled.scala.Parser.push.C">C</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule3">Rule3</span>[<span class="extype" name="org.parboiled.scala.Parser.push.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.push.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.push.C">C</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#push" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="push[A,B](a:=&gt;A,b:=&gt;B):org.parboiled.scala.Rule2[A,B]"></a>
      <a id="push[A,B](â‡’A,â‡’B):Rule2[A,B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">push</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="a">a: â‡’ <span class="extype" name="org.parboiled.scala.Parser.push.A">A</span></span>, <span name="b">b: â‡’ <span class="extype" name="org.parboiled.scala.Parser.push.B">B</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule2">Rule2</span>[<span class="extype" name="org.parboiled.scala.Parser.push.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.push.B">B</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#push" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="push[A](f:=&gt;A):org.parboiled.scala.Rule1[A]"></a>
      <a id="push[A](â‡’A):Rule1[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">push</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: â‡’ <span class="extype" name="org.parboiled.scala.Parser.push.A">A</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="org.parboiled.scala.Parser.push.A">A</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#pushFromContext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pushFromContext[A&lt;:&lt;?&gt;](f:&lt;?&gt;):org.parboiled.scala.Rule1[A]"></a>
      <a id="pushFromContext[A]((Context[Any])â‡’A):Rule1[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pushFromContext</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.parboiled.Context">Context</span>[<span class="extype" name="scala.Any">Any</span>]) â‡’ <span class="extype" name="org.parboiled.scala.Parser.pushFromContext.A">A</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="org.parboiled.scala.Parser.pushFromContext.A">A</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#rule" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rule[T&lt;:org.parboiled.scala.Rule](label:String,options:org.parboiled.scala.RuleOption*)(block:=&gt;T)(implicitcreator:org.parboiled.matchers.Matcher=&gt;T):T"></a>
      <a id="rule[T&lt;:Rule](String,RuleOption*)(â‡’T)((Matcher)â‡’T):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rule</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="org.parboiled.scala.Rule">Rule</span></span>]</span><span class="params">(<span name="label">label: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="options">options: <span class="extype" name="org.parboiled.scala.RuleOption">RuleOption</span>*</span>)</span><span class="params">(<span name="block">block: â‡’ <span class="extype" name="org.parboiled.scala.Parser.rule.T">T</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="creator">creator: (<span class="extype" name="org.parboiled.matchers.Matcher">Matcher</span>) â‡’ <span class="extype" name="org.parboiled.scala.Parser.rule.T">T</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Parser.rule.T">T</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#rule" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rule[T&lt;:org.parboiled.scala.Rule](firstOption:org.parboiled.scala.RuleOption,more:org.parboiled.scala.RuleOption*)(block:=&gt;T)(implicitcreator:org.parboiled.matchers.Matcher=&gt;T):T"></a>
      <a id="rule[T&lt;:Rule](RuleOption,RuleOption*)(â‡’T)((Matcher)â‡’T):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rule</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="org.parboiled.scala.Rule">Rule</span></span>]</span><span class="params">(<span name="firstOption">firstOption: <span class="extype" name="org.parboiled.scala.RuleOption">RuleOption</span></span>, <span name="more">more: <span class="extype" name="org.parboiled.scala.RuleOption">RuleOption</span>*</span>)</span><span class="params">(<span name="block">block: â‡’ <span class="extype" name="org.parboiled.scala.Parser.rule.T">T</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="creator">creator: (<span class="extype" name="org.parboiled.matchers.Matcher">Matcher</span>) â‡’ <span class="extype" name="org.parboiled.scala.Parser.rule.T">T</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Parser.rule.T">T</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#rule" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rule[T&lt;:org.parboiled.scala.Rule](block:=&gt;T)(implicitcreator:org.parboiled.matchers.Matcher=&gt;T):T"></a>
      <a id="rule[T&lt;:Rule](â‡’T)((Matcher)â‡’T):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rule</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="org.parboiled.scala.Rule">Rule</span></span>]</span><span class="params">(<span name="block">block: â‡’ <span class="extype" name="org.parboiled.scala.Parser.rule.T">T</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="creator">creator: (<span class="extype" name="org.parboiled.matchers.Matcher">Matcher</span>) â‡’ <span class="extype" name="org.parboiled.scala.Parser.rule.T">T</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Parser.rule.T">T</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#run" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="run(f:&lt;?&gt;):org.parboiled.scala.Rule0"></a>
      <a id="run(â‡’Unit):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">run</span><span class="params">(<span name="f">f: â‡’ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#str" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="str(chars:Array[Char]):org.parboiled.scala.Rule0"></a>
      <a id="str(Array[Char]):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">str</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#str" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="str(s:String):org.parboiled.scala.Rule0"></a>
      <a id="str(String):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">str</span><span class="params">(<span name="s">s: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](â‡’T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: â‡’ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#test" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="test(f:&lt;?&gt;):org.parboiled.scala.Rule0"></a>
      <a id="test(â‡’Boolean):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">test</span><span class="params">(<span name="f">f: â‡’ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#toLoc" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toLoc(context:org.parboiled.Context[_]):ornl.elision.util.Loc"></a>
      <a id="toLoc(Context[_]):Loc"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toLoc</span><span class="params">(<span name="context">context: <span class="extype" name="org.parboiled.Context">Context</span>[_]</span>)</span><span class="result">: <a href="../util/Loc.html" class="extype" name="ornl.elision.util.Loc">Loc</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Transform a Parboiled context into a location.</p><div class="fullcomment"><div class="comment cmt"><p>Transform a Parboiled context into a location.
</p></div><dl class="paramcmts block"><dt class="param">context</dt><dd class="cmt"><p>The parboiled context.</p></dd><dt>returns</dt><dd class="cmt"><p>The new location instance.
</p></dd></dl></div>
    </li><li name="ornl.elision.parse.ElisionParser#toRule" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toRule(string:String):org.parboiled.scala.rules.Rule0"></a>
      <a id="toRule(String):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toRule</span><span class="params">(<span name="string">string: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.rules.Rule0">Rule0</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Eliminate trailing whitespace.</p><div class="fullcomment"><div class="comment cmt"><p>Eliminate trailing whitespace.  This trick is found on the Parboiled web
site in the examples.
</p></div><dl class="paramcmts block"><dt class="param">string</dt><dd class="cmt"><p>Parsed text.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="ornl.elision.parse.ElisionParser">ElisionParser</a> â†’ Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#toRule" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toRule(symbol:Symbol):org.parboiled.scala.Rule0"></a>
      <a id="toRule(Symbol):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toRule</span><span class="params">(<span name="symbol">symbol: <span class="extype" name="scala.Symbol">Symbol</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#toRule" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toRule(chars:Array[Char]):org.parboiled.scala.Rule0"></a>
      <a id="toRule(Array[Char]):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toRule</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#withContext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withContext[A,B,C,D,E,F,G,R](f:(A,B,C,D,E,F,G,org.parboiled.Context[Any])=&gt;R):org.parboiled.scala.WithContextAction7[A,B,C,D,E,F,G,R]"></a>
      <a id="withContext[A,B,C,D,E,F,G,R]((A,B,C,D,E,F,G,Context[Any])â‡’R):WithContextAction7[A,B,C,D,E,F,G,R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withContext</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="D">D</span>, <span name="E">E</span>, <span name="F">F</span>, <span name="G">G</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.C">C</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.D">D</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.E">E</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.F">F</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.G">G</span>, <span class="extype" name="org.parboiled.Context">Context</span>[<span class="extype" name="scala.Any">Any</span>]) â‡’ <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.WithContextAction7">WithContextAction7</span>[<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.C">C</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.D">D</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.E">E</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.F">F</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.G">G</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#withContext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withContext[A,B,C,D,E,F,R](f:(A,B,C,D,E,F,org.parboiled.Context[Any])=&gt;R):org.parboiled.scala.WithContextAction6[A,B,C,D,E,F,R]"></a>
      <a id="withContext[A,B,C,D,E,F,R]((A,B,C,D,E,F,Context[Any])â‡’R):WithContextAction6[A,B,C,D,E,F,R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withContext</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="D">D</span>, <span name="E">E</span>, <span name="F">F</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.C">C</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.D">D</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.E">E</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.F">F</span>, <span class="extype" name="org.parboiled.Context">Context</span>[<span class="extype" name="scala.Any">Any</span>]) â‡’ <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.WithContextAction6">WithContextAction6</span>[<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.C">C</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.D">D</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.E">E</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.F">F</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#withContext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withContext[A,B,C,D,E,R](f:(A,B,C,D,E,org.parboiled.Context[Any])=&gt;R):org.parboiled.scala.WithContextAction5[A,B,C,D,E,R]"></a>
      <a id="withContext[A,B,C,D,E,R]((A,B,C,D,E,Context[Any])â‡’R):WithContextAction5[A,B,C,D,E,R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withContext</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="D">D</span>, <span name="E">E</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.C">C</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.D">D</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.E">E</span>, <span class="extype" name="org.parboiled.Context">Context</span>[<span class="extype" name="scala.Any">Any</span>]) â‡’ <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.WithContextAction5">WithContextAction5</span>[<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.C">C</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.D">D</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.E">E</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#withContext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withContext[A,B,C,D,R](f:(A,B,C,D,org.parboiled.Context[Any])=&gt;R):org.parboiled.scala.WithContextAction4[A,B,C,D,R]"></a>
      <a id="withContext[A,B,C,D,R]((A,B,C,D,Context[Any])â‡’R):WithContextAction4[A,B,C,D,R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withContext</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="D">D</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.C">C</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.D">D</span>, <span class="extype" name="org.parboiled.Context">Context</span>[<span class="extype" name="scala.Any">Any</span>]) â‡’ <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.WithContextAction4">WithContextAction4</span>[<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.C">C</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.D">D</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#withContext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withContext[A,B,C,R](f:(A,B,C,org.parboiled.Context[Any])=&gt;R):org.parboiled.scala.WithContextAction3[A,B,C,R]"></a>
      <a id="withContext[A,B,C,R]((A,B,C,Context[Any])â‡’R):WithContextAction3[A,B,C,R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withContext</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.C">C</span>, <span class="extype" name="org.parboiled.Context">Context</span>[<span class="extype" name="scala.Any">Any</span>]) â‡’ <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.WithContextAction3">WithContextAction3</span>[<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.C">C</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#withContext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withContext[A,B,R](f:(A,B,org.parboiled.Context[Any])=&gt;R):org.parboiled.scala.WithContextAction2[A,B,R]"></a>
      <a id="withContext[A,B,R]((A,B,Context[Any])â‡’R):WithContextAction2[A,B,R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withContext</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.Context">Context</span>[<span class="extype" name="scala.Any">Any</span>]) â‡’ <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.WithContextAction2">WithContextAction2</span>[<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.B">B</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#withContext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withContext[A,R](f:(A,org.parboiled.Context[Any])=&gt;R):org.parboiled.scala.WithContextAction1[A,R]"></a>
      <a id="withContext[A,R]((A,Context[Any])â‡’R):WithContextAction1[A,R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withContext</span><span class="tparams">[<span name="A">A</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.Context">Context</span>[<span class="extype" name="scala.Any">Any</span>]) â‡’ <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.WithContextAction1">WithContextAction1</span>[<span class="extype" name="org.parboiled.scala.Parser.withContext.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.withContext.R">R</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#zeroOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zeroOrMore[A,B](sub:org.parboiled.scala.Rule2[A,B],separator:org.parboiled.scala.Rule0):org.parboiled.scala.Rule1[List[(A,B)]]"></a>
      <a id="zeroOrMore[A,B](Rule2[A,B],Rule0):Rule1[List[(A,B)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zeroOrMore</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule2">Rule2</span>[<span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.B">B</span>]</span>, <span name="separator">separator: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[(<span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.B">B</span>)]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#zeroOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zeroOrMore[A](sub:org.parboiled.scala.Rule1[A],separator:org.parboiled.scala.Rule0):org.parboiled.scala.Rule1[List[A]]"></a>
      <a id="zeroOrMore[A](Rule1[A],Rule0):Rule1[List[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zeroOrMore</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.A">A</span>]</span>, <span name="separator">separator: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.A">A</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#zeroOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zeroOrMore(sub:org.parboiled.scala.Rule0,separator:org.parboiled.scala.Rule0):org.parboiled.scala.Rule0"></a>
      <a id="zeroOrMore(Rule0,Rule0):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zeroOrMore</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>, <span name="separator">separator: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#zeroOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zeroOrMore[A,B](sub:org.parboiled.scala.Rule2[A,B]):org.parboiled.scala.Rule1[List[(A,B)]]"></a>
      <a id="zeroOrMore[A,B](Rule2[A,B]):Rule1[List[(A,B)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zeroOrMore</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule2">Rule2</span>[<span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.B">B</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[(<span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.A">A</span>, <span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.B">B</span>)]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#zeroOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zeroOrMore[A](sub:org.parboiled.scala.Rule1[A]):org.parboiled.scala.Rule1[List[A]]"></a>
      <a id="zeroOrMore[A](Rule1[A]):Rule1[List[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zeroOrMore</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule1">Rule1</span>[<a href="../../../scala/package.html#List[+A]=List[A]" class="extmbr" name="scala.List">List</a>[<span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.A">A</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#zeroOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zeroOrMore[Z](sub:org.parboiled.scala.ReductionRule1[Z,Z]):org.parboiled.scala.ReductionRule1[Z,Z]"></a>
      <a id="zeroOrMore[Z](ReductionRule1[Z,Z]):ReductionRule1[Z,Z]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zeroOrMore</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.ReductionRule1">ReductionRule1</span>[<span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.Z">Z</span>, <span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.Z">Z</span>]</span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.ReductionRule1">ReductionRule1</span>[<span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.Z">Z</span>, <span class="extype" name="org.parboiled.scala.Parser.zeroOrMore.Z">Z</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li><li name="org.parboiled.scala.Parser#zeroOrMore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zeroOrMore(sub:org.parboiled.scala.Rule0):org.parboiled.scala.Rule0"></a>
      <a id="zeroOrMore(Rule0):Rule0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zeroOrMore</span><span class="params">(<span name="sub">sub: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>)</span><span class="result">: <span class="extype" name="org.parboiled.scala.Rule0">Rule0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parser</dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="ornl.elision.parse.AbstractParser">
              <h3>Inherited from <a href="AbstractParser.html" class="extype" name="ornl.elision.parse.AbstractParser">AbstractParser</a></h3>
            </div><div class="parent" name="org.parboiled.scala.Parser">
              <h3>Inherited from <span class="extype" name="org.parboiled.scala.Parser">Parser</span></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <a href="../../../scala/package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>