<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>ornl.elision.core.RulesetRef</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../../lib/template.css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
    
        </head>
        <body class="type">
      <div id="definition">
        <a title="Go to companion" href="RulesetRef$.html"><img src="../../../lib/class_to_object_big.png" /></a>
        <p id="owner"><a name="ornl" class="extype" href="../../package.html">ornl</a>.<a name="ornl.elision" class="extype" href="../package.html">elision</a>.<a name="ornl.elision.core" class="extype" href="package.html">core</a></p>
        <h1><a title="Go to companion" href="RulesetRef$.html">RulesetRef</a></h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="kind">class</span>
      <span class="symbol"> 
        <span class="name">RulesetRef</span>
        
        <span class="result"> extends <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a> with <a name="ornl.elision.core.Rewriter" class="extype" href="Rewriter.html">Rewriter</a></span>
      </span>
      </h4>
      
          <div class="fullcommenttop" id="comment"><div class="comment cmt"><p>A ruleset reference.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a name="ornl.elision.core.Rewriter" class="extype" href="Rewriter.html">Rewriter</a>, <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a>, AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div></div>
        

      <div id="template">

        <div id="mbrsel">
          <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
          <div id="order">
                <span class="filtertype">Ordering</span>
                <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
              </div>
          <div id="ancestors">
                <span class="filtertype">Inherited</span>
                <ol><li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show all</span></li></ol>
                <ol id="linearization"><li name="ornl.elision.core.RulesetRef" class="in"><span>RulesetRef</span></li><li name="ornl.elision.core.Rewriter" class="in"><span>Rewriter</span></li><li name="ornl.elision.core.BasicAtom" class="in"><span>BasicAtom</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
              </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>

        <div class="members" id="constructors">
              <h3>Instance Constructors</h3>
              <ol><li visbl="pub" name="ornl.elision.core.RulesetRef#this" data-isabs="false">
      <a id="this:RulesetRef"></a>
      <h4 class="signature">
      <span class="kind">new</span>
      <span class="symbol"> 
        <span class="name">RulesetRef</span>
        
        <span class="params">()</span>
      </span>
      </h4>
      
    </li></ol>
            </div>

        
        
        <div class="values members" id="values">
              <h3>Abstract Value Members</h3>
              <ol><li visbl="pub" name="ornl.elision.core.Rewriter#doRewrite" data-isabs="true">
      <a id="doRewrite(BasicAtom,Option[Any]):(BasicAtom, Boolean)"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">doRewrite</span>
        
        <span class="params">(<span name="atom">atom: <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></span>, <span name="hint">hint: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Any" class="extype">Any</span>] = <span class="symbol"><span class="name"><a href="../../../scala/package.html">None</a></span></span></span>)</span><span class="result">: (<a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a>, <span name="scala.Boolean" class="extype">Boolean</span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Apply this rewriter to the given atom, yielding a potentially new atom.</p><div class="fullcomment"><div class="comment cmt"><p>Apply this rewriter to the given atom, yielding a potentially new atom.
The rewriter must also provide a flag indicating whether it &quot;succeeded&quot;
in some appropriate sense.</p><p>The specific sense of &quot;success&quot; is dependent on the rewriter, and does
not necessarily mean that the rewritten atom is different from the
original atom.</p><p>Atoms that have this trait can be placed on the left-hand side of the
applicative dot.  This method will get invoked when that happens, with
the right-hand side passed as the atom.
</p></div><dl class="paramcmts block"><dt class="param">atom</dt><dd class="cmt"><p>The atom to rewrite.</p></dd><dt class="param">hint</dt><dd class="cmt"><p>An optional hint to pass along during matching.</p></dd><dt>returns</dt><dd class="cmt"><p>A pair consisting of a potentially new atom and a flag indicating
					success or failure.
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Definition Classes</dt><dd><a name="ornl.elision.core.Rewriter" class="extype" href="Rewriter.html">Rewriter</a></dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#name" data-isabs="true">
      <a id="name:String"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">name</span>
        
        <span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The name of the referenced ruleset.</p><div class="fullcomment"><div class="comment cmt"><p>The name of the referenced ruleset.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.BasicAtom#tryMatchWithoutTypes" data-isabs="true">
      <a id="tryMatchWithoutTypes(BasicAtom,Bindings,Option[Any]):Outcome"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">tryMatchWithoutTypes</span>
        
        <span class="params">(<span name="subject">subject: <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></span>, <span name="binds">binds: <a name="ornl.elision.core.Bindings" class="extype" href="Bindings.html">Bindings</a></span>, <span name="hints">hints: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <a name="ornl.elision.core.Outcome" class="extype" href="Outcome.html">Outcome</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Try to match this atom, as a pattern, against the given subject.</p><div class="fullcomment"><div class="comment cmt"><p>Try to match this atom, as a pattern, against the given subject.  Do not
do type matching for this atom, but use BasicAtom.tryMatch for any
children, so their types are correctly matched.
</p></div><dl class="paramcmts block"><dt class="param">subject</dt><dd class="cmt"><p>The subject atom to match.</p></dd><dt class="param">binds</dt><dd class="cmt"><p>Any bindings that must be observed.</p></dd><dt class="param">hints</dt><dd class="cmt"><p>Optional hints.</p></dd><dt>returns</dt><dd class="cmt"><p>The matching outcome.
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Definition Classes</dt><dd><a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li></ol>
            </div>

        <div class="values members" id="values">
              <h3>Concrete Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">##</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">asInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">clone</span>
        
        <span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#constantPool" data-isabs="false">
      <a id="constantPool:None.type"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">constantPool</span>
        
        <span class="result">: None.type</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A mapping from known constant descendants to their child index.</p><div class="fullcomment"><div class="comment cmt"><p>A mapping from known constant descendants to their child index.</p><p>This works as follows.  For constants, and for atoms that do not have any
atom children, the constant pool is empty.  In fact, to conserve space the
constant pool can be omitted by setting it to <code>None</code>.</p><p>For nodes that have atom children each child should be queried to determine
if it is a constant.  If so, get its hash code, merge it with the atom's
own top level code (the name of an operator or some other relevant item),
and store it in the pool.</p><p>If a child is not a constant, get its constant pool and iterate over it,
adding the atom's own top level code to each hash code, and putting the
result in the pool.</p><p>See the function <code>buildConstantPool</code> in the companion object for help with
all this.  That function should be sufficient for nearly all atoms.</p><p>Suppose you have a complicated case, such as two distinguished children
alice and bob, and then a litter of others.  Your constructor might be</p><pre>
class Klaus(alice: BasicAtom, bob: BasicAtom, litter: BasicAtom*)
</pre><p>Computing the constant pool for this using the <code>buildConstantPool</code> works
like this.</p><pre>
val constantPool =
    Some(BasicAtom.buildConstantPool(&quot;Klaus&quot;.hashCode,
        (pattern +: rewrite +: guards):_*))
</pre><p>Everything else should be significantly easier!
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#deBruijnIndex" data-isabs="false">
      <a id="deBruijnIndex:Int"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">deBruijnIndex</span>
        
        <span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The De Bruijn index.</p><div class="fullcomment"><div class="comment cmt"><p>The De Bruijn index.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#depth" data-isabs="false">
      <a id="depth:Int"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">depth</span>
        
        <span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The depth of the atom.</p><div class="fullcomment"><div class="comment cmt"><p>The depth of the atom.  An atom's depth is equal to the maximum depth
of its children, plus one.  An atom with no children has depth zero.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">eq</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">equals</span>
        
        <span class="params">(<span name="other">other: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.BasicAtom#evenMeta" data-isabs="false">
      <a id="evenMeta:Boolean"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">evenMeta</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Whether this atom should be applied, even on meta-terms.</p><div class="fullcomment"><div class="comment cmt"><p>Whether this atom should be applied, even on meta-terms.  Do not mess
with this; unless you are modifying the Elision language you want to
leave this alone.  Only exceptional operators that must operate
handlers to terms that will contain meta-terms need to change this.
For nearly every operator the default handling of meta-terms is
appropriate.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">finalize</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">getClass</span>
        
        <span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">hashCode</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.BasicAtom#isBindable" data-isabs="false">
      <a id="isBindable:Boolean"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">isBindable</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">If true then this atom can be bound.</p><div class="fullcomment"><div class="comment cmt"><p>If true then this atom can be bound.  Only variables should be bound, so
override this for variables; it is <code>false</code> by default.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#isConstant" data-isabs="false">
      <a id="isConstant:Boolean"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">isConstant</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">If true then this atom denotes a constant (it contains no variables).</p><div class="fullcomment"><div class="comment cmt"><p>If true then this atom denotes a constant (it contains no variables).</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.BasicAtom#isDeBruijnIndex" data-isabs="false">
      <a id="isDeBruijnIndex:Boolean"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">isDeBruijnIndex</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Iff true, this is a De Bruijn index.</p><div class="fullcomment"><div class="comment cmt"><p>Iff true, this is a De Bruijn index.  A De Bruijn index is a special kind
of variable that is used during alpha conversion of lambdas.  If you are
not writing code for a lambda, you can ignore this.  Otherwise you need to
convert variables bound by the lambda into De Bruijn indices.  This flag
is used to protect De Bruijn indices against further rewriting.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.BasicAtom#isFalse" data-isabs="false">
      <a id="isFalse:Boolean"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">isFalse</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">If true, this atom represents false.</p><div class="fullcomment"><div class="comment cmt"><p>If true, this atom represents false.  Override this for an atom that
represents false.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#isTerm" data-isabs="false">
      <a id="isTerm:Boolean"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">isTerm</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">If true then this atom denotes a term.</p><div class="fullcomment"><div class="comment cmt"><p>If true then this atom denotes a term.  If false, a metaterm.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.BasicAtom#isTrue" data-isabs="false">
      <a id="isTrue:Boolean"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">isTrue</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">If true, this atom represents true.</p><div class="fullcomment"><div class="comment cmt"><p>If true, this atom represents true.  Override this for an atom that
represents true.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="prt" name="ornl.elision.core.BasicAtom#matchTypes" data-isabs="false">
      <a id="matchTypes(BasicAtom,Bindings,Option[Any]):Outcome"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">matchTypes</span>
        
        <span class="params">(<span name="subject">subject: <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></span>, <span name="binds">binds: <a name="ornl.elision.core.Bindings" class="extype" href="Bindings.html">Bindings</a></span>, <span name="hints">hints: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <a name="ornl.elision.core.Outcome" class="extype" href="Outcome.html">Outcome</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Recursively match the types.</p><div class="fullcomment"><div class="comment cmt"><p>Recursively match the types.  This is unbounded recursion; it is expected
that a class (a type universe) will override this method to create a basis
case.</p><p>NOTE: When strategies are finally implemented, this is where the selection
of type matching strategies may be done.
</p></div><dl class="paramcmts block"><dt class="param">subject</dt><dd class="cmt"><p>The atom to match.</p></dd><dt class="param">binds</dt><dd class="cmt"><p>The bindings to observe.</p></dd><dt class="param">hints</dt><dd class="cmt"><p>Optional hints.</p></dd><dt>returns</dt><dd class="cmt"><p>The outcome of the match.
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">ne</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">notify</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">notifyAll</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#rewrite" data-isabs="false">
      <a id="rewrite(Bindings):(RulesetRef, Boolean)"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">rewrite</span>
        
        <span class="params">(<span name="binds">binds: <a name="ornl.elision.core.Bindings" class="extype" href="Bindings.html">Bindings</a></span>)</span><span class="result">: (<a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a>, <span name="scala.Boolean" class="extype">Boolean</span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Ruleset references cannot be rewritten.</p><div class="fullcomment"><div class="comment cmt"><p>Ruleset references cannot be rewritten.</p></div><dl class="paramcmts block"><dt class="param">binds</dt><dd class="cmt"><p>The bindings.
</p></dd><dt>returns</dt><dd class="cmt"><p>The result of rewriting this atom, and whether or not anything
					changed.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">synchronized</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#theType" data-isabs="false">
      <a id="theType:ornl.elision.core.RSREF.type"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">theType</span>
        
        <span class="result">: ornl.elision.core.RSREF.type</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The type for the atom.</p><div class="fullcomment"><div class="comment cmt"><p>The type for the atom.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#toParseString" data-isabs="false">
      <a id="toParseString:String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toParseString</span>
        
        <span class="result">: <span name="java.lang.String" class="extype">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Generate a parseable string from this atom.</p><div class="fullcomment"><div class="comment cmt"><p>Generate a parseable string from this atom.  The returned string should
be able to &quot;round trip,&quot; that is, <a name="ornl.elision.parse.AtomParser" class="extype" href="../parse/AtomParser.html">AtomParser</a> must
be able to parse it and return an atom equal to this one.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The string.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.RulesetRef#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toString</span>
        
        <span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.RulesetRef" class="extype" href="">RulesetRef</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="ornl.elision.core.BasicAtom#tryMatch" data-isabs="false">
      <a id="tryMatch(BasicAtom,Bindings,Option[Any]):Outcome"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">tryMatch</span>
        
        <span class="params">(<span name="subject">subject: <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></span>, <span name="binds">binds: <a name="ornl.elision.core.Bindings" class="extype" href="Bindings.html">Bindings</a> = <span class="symbol"><span class="name"><a href="Bindings$.html">Bindings()</a></span></span></span>, <span name="hints">hints: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Any" class="extype">Any</span>] = <span class="symbol"><span class="name"><a href="../../../scala/package.html">None</a></span></span></span>)</span><span class="result">: <a name="ornl.elision.core.Outcome" class="extype" href="Outcome.html">Outcome</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Attempt to match this atom, as a pattern, against the subject atom,
observing the bindings, if any.</p><div class="fullcomment"><div class="comment cmt"><p>Attempt to match this atom, as a pattern, against the subject atom,
observing the bindings, if any.  The type is checked prior to trying
any matching.
</p></div><dl class="paramcmts block"><dt class="param">subject</dt><dd class="cmt"><p>The subject atom to match.</p></dd><dt class="param">binds</dt><dd class="cmt"><p>Any bindings that must be observed.  This is optional.</p></dd><dt class="param">hints</dt><dd class="cmt"><p>Optional hints.</p></dd><dt>returns</dt><dd class="cmt"><p>The matching outcome.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        <div name="ornl.elision.core.Rewriter" class="parent">
              <h3>Inherited from <a name="ornl.elision.core.Rewriter" class="extype" href="Rewriter.html">Rewriter</a></h3>
            </div><div name="ornl.elision.core.BasicAtom" class="parent">
              <h3>Inherited from <a name="ornl.elision.core.BasicAtom" class="extype" href="BasicAtom.html">BasicAtom</a></h3>
            </div><div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>

      </div>
      
      <div id="tooltip"></div>
      
    </body>
      </html>